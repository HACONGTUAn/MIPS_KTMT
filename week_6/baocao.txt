bai1:
.data
A: .word -2, 6, -1, 3, -2
.text
main:       
la $a0,A
li $a1,5
j mspfx
nop
continue:
lock:       j lock
nop
end_of_main:
mspfx:  addi $v0,$zero,0#initialize length in $v0 to 0
addi $v1,$zero,0#initialize max sum in $v1to 0
addi $t0,$zero,0#initialize index i in $t0 to 0
addi $t1,$zero,0#initialize running sum in $t1 to 0
loop: add $t2,$t0,$t0#put 2i in $t2
add $t2,$t2,$t2#put 4i in $t2
add $t3,$t2,$a0#put 4i+A (address of A[i]) in $t3
lw $t4,0($t3)#load A[i] from mem(t3) into $t4
add $t1,$t1,$t4#add A[i] to running sum in $t1
slt $t5,$v1,$t1#set $t5 to 1 if max sum < new sum
bne $t5,$zero,mdfy #if max sum is less, modify results
j test#done?
mdfy:addi $v0,$t0,1#new max-sum prefix has length i+1
addi $v1,$t1,0#new max sum is the running sum
test:addi $t0,$t0,1#advance the index i
slt $t5,$t0,$a1#set $t5 to 1 if i<n
bne $t5,$zero,loop#repeat if i<n
done: j continue
mspfx_end:
bai 2:
.data
A: .word 7, -2, 5, 1, 5,6,7,3,6,8,8,59,5
Aend: .word 
.text
main: la $a0,A       #$a0 = Address(A[0])
la $a1,Aend
addi $a1,$a1,-4   #$a1 = Address(A[n-1])
j sort            #sort
after_sort: li $v0, 10#exit
syscall
end_main:
sort:       beq$a0,$a1,done#single element list is sorted
j max#call the max procedureafter_max:  
lw $t0,0($a1)#load last element into $t0
sw $t0,0($v0)#copy last element to max location
sw $v1,0($a1)#copy max value to last element
addi $a1,$a1,-4   #decrement pointer to last element
j sort#repeat sort for smaller list
done:       j after_sort
max:addi$v0,$a0,0         #init max pointer to first element
lw $v1,0($v0)        #init max value to first value
addi $t0,$a0,0         #init next pointer to first
loop:
beq $t0,$a1,ret       #if next=last, return
addi $t0,$t0,4         #advance to next element
lw $t1,0($t0)        #load next element into $t1
slt $t2,$t1,$v1       #(next)<(max) ?
bne $t2,$zero,loop#if (next)<(max), repeat
addi $v0,$t0,0#next element is new max element
addi $v1,$t1,0#next value is new max value
j loop#change completed; now repeat
ret:
j after_max